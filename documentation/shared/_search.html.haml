= title_anchor 'h2', 'search', "Search Parameters"

:markdown
  When searching for Entries and Content Types you can customize the
  search query in many ways.

- # TODO: add some examples in text? e.g. search for all restaurants around a location and filter them by tags... or whatever

= title_anchor 'h3', 'search-content-type', "Content Type"

:markdown
  Search for Entries with a specific Content Type by setting the `content_type`
  URI query parameter to the ID of the Content Type you want to search for'.

= language_specific 'http' do
  :markdown

    Please note that only one value for `content_type` can be specified at a time. Requests like the
    one below (where `content_type` is set to cat and dog) are not supported:

  = language_block :shell do
    = curl path: "/spaces/#{space}/entries?content_type=cat,dog"

  When querying Entries and using search filters based on `fields` or ordering by `fields`
  you must specify this parameter.

  Let's find all Entries of Content Type "cat":

= code_examples do
  = language_block :java do
    :plain
      client.entries().async().fetchAll(
          new HashMap<String, String>() {{
            put("content_type", "cat");
          }},

          new CDACallback<CDAArray>() {
            @Override protected void onSuccess(CDAArray result) {
              // ...
            }
          });

  = language_block :javascript do
    :plain
      client.entries({
        'content_type': 'cat'
      }).then(log.ok, log.fail);
  = language_block :shell do
    = curl path: "/spaces/#{space}/entries?content_type=cat"

  = api_console_trigger :action => 'entries', :params => {:filtering => ['equality;content_type;cat']}

  = language_block :objc do
    :plain
      [client fetchEntriesMatching:@{ @"content_type": @"cat" }
                           success:^(CDAResponse *response, CDAArray *array) {
                               NSLog(@"%@", array);
                           } failure:^(CDAResponse *response, NSError *error) {
                               NSLog(@"%@", error);
                           }];
  = language_block :swift do
    :plain
      client.fetchEntriesMatching([ "content_type": "cat" ],
        success: { (response: CDAResponse!, array: CDAArray!) -> Void in
          println((array.items[0] as CDAEntry).fields.allKeys)
        },
        failure: { (response: CDAResponse!, error: NSError!) -> Void in
          println(error)
        })
  = language_block :ruby do
    :plain
      client.entries('content_type' => 'cat')

= title_anchor 'h3', 'search-filter', "Filters"

:markdown
  Search filters allow you to filter by resources' fields in powerful ways:

  - [Content Type](#search-content-type): Search only Entries with a specific Content Type
  - [Equality & Inequality](#search-filter-equality): Search for exact matches.
  - [Inclusion & Exclusion](#search-filter-inclusion): Search for multiple matches.
  - [Number & Date Ranges](#search-filter-range): Search for dates before/after a certain time; numbers within boundaries.
  - [Full-Text](#search-filter-full-text): Search for words or whole sentences within texts.
  - [Geographical Boundaries](#search-filter-geo): Search within a geographical rectangle or circle.

:markdown
  Note that if you're searching Entries and filtering or ordering by `fields` you *must*
  specify the `content_type` parameter. See [range filtering](#search-filter-range) for an example of this.
  If you're filtering or ordering by `sys` you don't need to specify the parameter.

= title_anchor 'h4', 'search-filter-equality', "Equality & Inequality"

:markdown
  Search for exact matches by using the equality operator.

  Let's find all Entries with ID `nyancat` (hint: IDs are unique and there can only be one):

= code_examples do
  = language_block :java do
    :plain
      client.entries().async().fetchAll(
          new HashMap<String, String>() {{
            put("sys.id", "nyancat");
          }},

          new CDACallback<CDAArray>() {
            @Override protected void onSuccess(CDAArray result) {
              // ...
            }
          });


  = language_block :javascript do
    :plain
      client.entries({
        'sys.id': 'nyancat'
      }).then(log.ok, log.fail);

  = language_block :shell do
    = curl path: "/spaces/#{space}/entries?sys.id=nyancat"

  = api_console_trigger :action => 'entries', :params => {:filtering => 'equality;sys.id;nyancat'}

  = language_block :objc do
    :plain
      [client fetchEntriesMatching:@{ @"sys.id": @"nyancat" }
                           success:^(CDAResponse *response, CDAArray *array) {
                               NSLog(@"%@", array);
                           } failure:^(CDAResponse *response, NSError *error) {
                               NSLog(@"%@", error);
                           }];
  = language_block :swift do
    :plain
      client.fetchEntriesMatching([ "sys.id": "nyancat" ],
        success: { (response: CDAResponse!, array: CDAArray!) -> Void in
          println((array.items[0] as CDAEntry).fields.allKeys)
        },
        failure: { (response: CDAResponse!, error: NSError!) -> Void in
          println(error)
        })

:markdown
  A reason to query an Entry by ID like above instead of [retrieving the Entry itself](#getting-entry)
  might be because you want to [include resolved links](#search-link).

  Note that equality & inequality operators are **not supported** for `Text` fields.

  The inequality operator can be used to look for fields that _don't_ match a specific value.

  For example, here's how to get all Entries except nyancat:

= code_examples do
  = language_block :java do
    :plain
      client.entries().async().fetchAll(
          new HashMap<String, String>() {{
            put("sys.id[ne]", "nyancat");
          }},

          new CDACallback<CDAArray>() {
            @Override protected void onSuccess(CDAArray result) {
              // ...
            }
          });

  = language_block :javascript do
    :plain
      client.entries({
        'sys.id[ne]': 'nyancat'
      }).then(log.ok, log.fail);
  = language_block :shell do
    = curl path: "/spaces/#{space}/entries?sys.id[ne]=nyancat"

  = api_console_trigger :action => 'entries', :params => {:filtering => 'not-equal;sys.id;nyancat'}

  = language_block :objc do
    :plain
      [client fetchEntriesMatching:@{ @"sys.id[ne]": @"nyancat" }
                           success:^(CDAResponse *response, CDAArray *array) {
                               NSLog(@"%@", array);
                           } failure:^(CDAResponse *response, NSError *error) {
                               NSLog(@"%@", error);
                           }];
  = language_block :swift do
    :plain
      client.fetchEntriesMatching([ "sys.id[ne]": "nyancat" ],
        success: { (response: CDAResponse!, array: CDAArray!) -> Void in
          println((array.items[0] as CDAEntry).fields.allKeys)
        },
        failure: { (response: CDAResponse!, error: NSError!) -> Void in
          println(error)
        })
  = language_block :ruby do
    :plain
      client.entries('sys.id[ne]' => 'nyancat')

:markdown
  The equality/inequality operators also works with Array fields:
  If one of the items in an Array field matches the value the field will match.

  Let's find all cats who like lasagna by matching `fields.likes` (Array) against a single value:

= code_examples do
  = language_block :java do
    :plain
      client.entries().async().fetchAll(
          new HashMap<String, String>() {{
            put("content_type", "cat");
            put("fields.likes", "lasagna");
          }},

          new CDACallback<CDAArray>() {
            @Override protected void onSuccess(CDAArray result) {
              // ...
            }
          });

  = language_block :javascript do
    :plain
      client.entries({
        'content_type': 'cat',
        'fields.likes': 'lasagna'
      }).then(log.ok, log.fail);
  = language_block :shell do
    = curl path: "/spaces/#{space}/entries?content_type=cat&fields.likes=lasagna"

  = api_console_trigger :action => 'entries', :params => {:filtering => ['equality;content_type;cat','equality;fields.likes;lasagna']}

  = language_block :objc do
    :plain
      [client fetchEntriesMatching:@{ @"content_type": @"cat",
                                    @"fields.likes": @"lasagna" }
                           success:^(CDAResponse *response, CDAArray *array) {
                               NSLog(@"%@", array);
                           } failure:^(CDAResponse *response, NSError *error) {
                               NSLog(@"%@", error);
                           }];
  = language_block :swift do
    :plain
      client.fetchEntriesMatching([ "content_type": "cat",
                                    "fields.likes": "lasagna" ],
        success: { (response: CDAResponse!, array: CDAArray!) -> Void in
          println((array.items[0] as CDAEntry).fields.allKeys)
        },
        failure: { (response: CDAResponse!, error: NSError!) -> Void in
          println(error)
        })
  = language_block :ruby do
    :plain
      client.entries('content_type' => 'cat', 'fields.likes' => 'lasagna')

= title_anchor 'h4', 'search-filter-inclusion', "Inclusion & Exclusion"

:markdown
  Filter a field by multiple values via the `in` operator.

  When applied to an array value there must be at least one matching item.

  Let's get Entries for finn and jake:

= code_examples do
  = language_block :java do
    :plain
      client.entries().async().fetchAll(
          new HashMap<String, String>() {{
            put("sys.id[in]", "finn,jake");
          }},

          new CDACallback<CDAArray>() {
            @Override protected void onSuccess(CDAArray result) {
              // ...
            }
          });

  = language_block :javascript do
    :plain
      client.entries({
        'sys.id[in]': ['finn', 'jake']
      }).then(log.ok, log.fail);

  = language_block :shell do
    = curl path: "/spaces/#{space}/entries?sys.id[in]=finn,jake"

  = api_console_trigger :action => 'entries', :params => {:filtering => ['inclusion;sys.id;finn,jake']}

  = language_block :objc do
    :plain
      [client fetchEntriesMatching:@{ @"sys.id[in]": @[ @"finn", @"jake" ] }
                           success:^(CDAResponse *response, CDAArray *array) {
                               NSLog(@"%@", array);
                           } failure:^(CDAResponse *response, NSError *error) {
                               NSLog(@"%@", error);
                           }];
  = language_block :swift do
    :plain
      client.fetchEntriesMatching([ "sys.id[in]": [ "finn", "jake" ] ],
        success: { (response: CDAResponse!, array: CDAArray!) -> Void in
          println((array.items[0] as CDAEntry).fields.allKeys)
        },
        failure: { (response: CDAResponse!, error: NSError!) -> Void in
          println(error)
        })
  = language_block :ruby do
    :plain
      client.entries('sys.id[in]' => 'finn,jake')


:markdown
  Let's get all cats that like neither rainbows nor lasagna:

= code_examples do
  = language_block :java do
    :plain
      client.entries().async().fetchAll(
          new HashMap<String, String>() {{
            put("content_type", "cat");
            put("fields.likes[nin]", "rainbows,lasagna");
          }},

          new CDACallback<CDAArray>() {
            @Override protected void onSuccess(CDAArray result) {
              // ...
            }
          });

  = language_block :javascript do
    :plain
      client.entries({
        'content_type': 'cat',
        'fields.likes[nin]': ['rainbows', 'lasagna']
      }).then(log.ok, log.fail);

  = language_block :shell do
    = curl path: "/spaces/#{space}/entries?content_type=cat&fields.likes[nin]=rainbows,lasagna"

  = api_console_trigger :action => 'entries', :params => {:filtering => ['equality;content_type;cat','not-inclusion;fields.likes;rainbows,lasagna']}

  = language_block :objc do
    :plain
      [client fetchEntriesMatching:@{ @"content_type": @"cat",
                                      @"fields.likes[nin]": @[ @"rainbows", @"lasagna" ] }
                           success:^(CDAResponse *response, CDAArray *array) {
                               NSLog(@"%@", array);
                           } failure:^(CDAResponse *response, NSError *error) {
                               NSLog(@"%@", error);
                           }];
  = language_block :swift do
    :plain
      client.fetchEntriesMatching([ "content_type": "cat",
                                    "fields.likes[nin]": [ "rainbows", "lasagna" ] ],
        success: { (response: CDAResponse!, array: CDAArray!) -> Void in
          println((array.items[0] as CDAEntry).fields.allKeys)
        },
        failure: { (response: CDAResponse!, error: NSError!) -> Void in
          println(error)
        })
  = language_block :ruby do
    :plain
      client.entries('sys.id[nin]' => 'rainbow,lasagna')

= title_anchor 'h4', 'search-filter-range', "Number & Date Ranges"

:markdown
  Four range operators are available:

  - `lt`: Less than
  - `lte`: Less than or equal to
  - `gt`: Greater than
  - `gte`: Greater than or equal to

  Those operators can be applied to Date, Integer and Number Fields.

  Let's find all cats which have 3 or less lives left:

- # TODO: Date, Integer and *Float* Fields?

= code_examples do
  = language_block :java do
    :plain
      client.entries().async().fetchAll(
          new HashMap<String, String>() {{
            put("content_type", "cat");
            put("fields.lives[lte]", "3");
          }},

          new CDACallback<CDAArray>() {
            @Override protected void onSuccess(CDAArray result) {
              // ...
            }
          });

  = language_block :javascript do
    :plain
      client.entries({
        'content_type': 'cat',
        'fields.lives[lte]': 3
      }).then(log.ok, log.fail);

  = language_block :shell do
    = curl path: "/spaces/#{space}/entries?content_type=cat&fields.lives[lte]=3"

  = api_console_trigger :action => 'entries', :params => {:filtering => ['equality;content_type;cat','less-than-equal;fields.lives;3']}

  = language_block :objc do
    :plain
      [client fetchEntriesMatching:@{ @"content_type": @"cat",
                                      @"fields.lives[lte]": @(3) }
                           success:^(CDAResponse *response, CDAArray *array) {
                               NSLog(@"%@", array);
                           } failure:^(CDAResponse *response, NSError *error) {
                               NSLog(@"%@", error);
                           }];

  = language_block :swift do
    :plain
      client.fetchEntriesMatching([ "content_type": "cat", "fields.lives[lte]": 3 ],
        success: { (response: CDAResponse!, array: CDAArray!) -> Void in
          println((array.items[0] as CDAEntry).fields.allKeys)
        },
        failure: { (response: CDAResponse!, error: NSError!) -> Void in
          println(error)
        })

  = language_block :ruby do
    :plain
      client.entries('content_type' => 'cat', 'fields.lives[lte]' => '3')

:markdown
  These cats should be more careful!

  We can also filter by date ranges.

  Let's look for Entries that've been updated since midnight of January 1st 2013:

= code_examples do
  = language_block :java do
    :plain
      client.entries().async().fetchAll(
          new HashMap<String, String>() {{
            put("sys.updatedAt[gte]", "2013-01-02T00:00:00Z");
          }},

          new CDACallback<CDAArray>() {
            @Override protected void onSuccess(CDAArray result) {
              // ...
            }
          });

  = language_block :javascript do
    :plain
      client.entries({
        'sys.updatedAt[gte]': '2013-01-01T00:00:00Z'
      }).then(log.ok, log.fail);

  = language_block :shell do
    = curl path: "/spaces/#{space}/entries?sys.updatedAt[gte]=2013-01-01T00:00:00Z"

  = api_console_trigger :action => 'entries', :params => {:filtering => ['greater-than-equal;sys.updatedAt;2013-01-01T00:00:00Z']}

  = language_block :objc do
    :plain
      NSDate* date = [[ISO8601DateFormatter new] dateFromString:@"2013-01-01T00:00:00Z"];

      [client fetchEntriesMatching:@{ @"sys.updatedAt[gte]": date }
                           success:^(CDAResponse *response, CDAArray *array) {
                               NSLog(@"%@", array);
                           } failure:^(CDAResponse *response, NSError *error) {
                               NSLog(@"%@", error);
                           }];

  = language_block :swift do
    :plain
      var date = ISO8601DateFormatter().dateFromString("2013-01-01T00:00:00Z")

      client.fetchEntriesMatching([ "sys.updatedAt[gte]": date ],
        success: { (response: CDAResponse!, array: CDAArray!) -> Void in
          println((array.items[0] as CDAEntry).fields.allKeys)
        },
        failure: { (response: CDAResponse!, error: NSError!) -> Void in
          println(error)
        })

  = language_block :ruby do
    :plain
      client.entries 'sys.updatedAt[gte]' => DateTime.parse('2013-01-02T00:00:00Z')
      # or
      client.entries 'sys.updatedAt[gte]' => '2013-01-02T00:00:00Z'


= title_anchor 'h4', 'search-filter-full-text', "Full-text Search"

- # TODO: explain more what full text search does. e.g. word stemming. case sensitivity. etc.

:markdown
  Full-text search across all Text and Symbol Fields via `query` querystring parameter. Please take into account that full text search
  is case insensitive and therefore you might get more results than expected.

  Let's find all Entries matching "bacon":

= code_examples do
  = language_block :java do
    :plain
      client.entries().async().fetchAll(
          new HashMap<String, String>() {{
            put("query", "bacon");
          }},

          new CDACallback<CDAArray>() {
            @Override protected void onSuccess(CDAArray result) {
              // ...
            }
          });

  = language_block :javascript do
    :plain
      client.entries({query: 'bacon'}).then(log.ok, log.fail);

  = language_block :shell do
    = curl path: "/spaces/#{space}/entries?query=bacon"

  = api_console_trigger :action => 'entries', :params => {:filtering => ['equality;query;bacon']}

  = language_block :objc do
    :plain
      [client fetchEntriesMatching:@{ @"query": @"bacon" }
                           success:^(CDAResponse *response, CDAArray *array) {
                               NSLog(@"%@", array);
                           } failure:^(CDAResponse *response, NSError *error) {
                               NSLog(@"%@", error);
                           }];
  = language_block :swift do
    :plain
      client.fetchEntriesMatching([ "query": "bacon" ],
        success: { (response: CDAResponse!, array: CDAArray!) -> Void in
          println((array.items[0] as CDAEntry).fields.allKeys)
        },
        failure: { (response: CDAResponse!, error: NSError!) -> Void in
          println(error)
        })
  = language_block :ruby do
    :plain
      client.entries('query' => 'bacon')



:markdown
  Full-text Search on a specific field via `match` operator.

  Let's find all things with "bacon pancakes" in their `description`:

= code_examples do
  = language_block :java do
    :plain
      client.entries().async().fetchAll(
          new HashMap<String, String>() {{
            put("content_type", "dog");
            put("fields.description[match]", "bacon pancakes");
          }},

          new CDACallback<CDAArray>() {
            @Override protected void onSuccess(CDAArray result) {
              // ...
            }
          });

  = language_block :javascript do
    :plain
      client.entries({
        'content_type': 'dog',
        'fields.description[match]': 'bacon pancakes'
      }).then(log.ok, log.fail);

  = language_block :shell do
    = curl path: "/spaces/#{space}/entries?content_type=dog&fields.description\[match\]=bacon"

  = api_console_trigger :action => 'entries', :params => {:filtering => ['equality;content_type;dog','match;fields.description;bacon']}

  = language_block :objc do
    :plain
      [client fetchEntriesMatching:@{ @"content_type": @"dog",
                                      @"fields.description[match]": @"bacon pancakes" }
                           success:^(CDAResponse *response, CDAArray *array) {
                               NSLog(@"%@", array);
                           } failure:^(CDAResponse *response, NSError *error) {
                               NSLog(@"%@", error);
                           }];
  = language_block :swift do
    :plain
      client.fetchEntriesMatching([ "content_type": "dog",
                                    "fields.description[match]": "bacon pancakes" ],
        success: { (response: CDAResponse!, array: CDAArray!) -> Void in
          println((array.items[0] as CDAEntry).fields.allKeys)
        },
        failure: { (response: CDAResponse!, error: NSError!) -> Void in
          println(error)
        })
  = language_block :ruby do
    :plain
      client.entries('content_type'=> 'dog', 'fields.description[match]' => 'bacon pancakes')

= title_anchor 'h4', 'search-filter-geo', "Location-based search"

:markdown
  Contentful works great with location-enabled content:

  - Let users find places closest to where they currently are
  - Show places within a specific map area
  - Find places in the vicinity of another place

  Entries can have location fields. For example, imagine a Restaurant Entry
  with a field called `location` indicating where the Restaurant is located.
  Once you've added location information to your content you can benefit from
  all of the above features simply by using the search in a specific way:

%h5 Restaurants "near me"

:markdown
  A common use case for location search is to search for places close to the
  user's current position.

  Use the `near` operator to show results closest to a specific map location and
  order the results by distance.

= language_specific 'java' do
  = language_block :java do
    :plain
      client.entries().async().fetchAll(
          new HashMap<String, String>() {{
            put("content_type", "restaurant");
            put("fields.location[near]", "23,42");
          }},

          new CDACallback<CDAArray>() {
            @Override protected void onSuccess(CDAArray result) {
              // ...
            }
          });

= language_specific 'javascript', 'http' do

  :markdown

        fields.location[near]=23,42&content_type=restaurant

= language_specific 'objc' do

  = language_block :objc do
    :plain
      [client fetchEntriesMatching:@{ @"fields.location[near]": @[ @23, @42 ],
                                      @"content_type": @"restaurant" }
                           success:^(CDAResponse *response, CDAArray *array) {
                              NSLog(@"%@", array);
                           } failure:^(CDAResponse *response, NSError *error) {
                              NSLog(@"Error: %@", error);
                           }];

= language_specific 'swift' do

  = language_block :swift do
    :plain
      client.fetchEntriesMatching([ "fields.location[near]": [ 23, 42],
                                    "content_type": "restaurant" ],
        success: { (response: CDAResponse!, array: CDAArray!) -> Void in
          println((array.items[0] as CDAEntry).fields.allKeys)
        },
        failure: { (response: CDAResponse!, error: NSError!) -> Void in
          println(error)
        })

= language_specific 'ruby' do
  = language_block :ruby do
    :plain
      client.entries('content_type' => 'restaurant', 'fields.Location[near]' => '23,42')

:markdown
  This will return all entries sorted by distance from the point at latitude=23
  and a longitude=42.

%h5 Search within bounding rectangle

:markdown
  When you're displaying content on a map it makes sense to retrieve only
  content that is visible on the currently visible map rectangle.

  For this case, use the `within` operator with the following value:

= language_specific 'java' do
  = language_block :java do
    :plain
        client.entries().async().fetchAll(
            new HashMap<String, String>() {{
              put("content_type", "restaurant");
              put("fields.location[within]", "1,2,3,4");
            }},

            new CDACallback<CDAArray>() {
              @Override protected void onSuccess(CDAArray result) {
                // ...
              }
            });

= language_specific 'javascript', 'http' do

  :markdown

        fields.location[within]=1,2,3,4&content_type=restaurant

= language_specific 'objc' do

  = language_block :objc do
    :plain
      [client fetchEntriesMatching:@{ @"fields.location[within]": @[ @1, @2, @3, @4 ],
                                      @"content_type": @"restaurant" }
                           success:^(CDAResponse *response, CDAArray *array) {
                              NSLog(@"%@", array);
                           } failure:^(CDAResponse *response, NSError *error) {
                              NSLog(@"Error: %@", error);
                           }];

= language_specific 'swift' do

  = language_block :swift do
    :plain
      client.fetchEntriesMatching([ "fields.location[within]": [ 1, 2, 3, 4 ],
                                    "content_type": "restaurant" ],
        success: { (response: CDAResponse!, array: CDAArray!) -> Void in
          println((array.items[0] as CDAEntry).fields.allKeys)
        },
        failure: { (response: CDAResponse!, error: NSError!) -> Void in
          println(error)
        })

= language_specific 'ruby' do

  = language_block :ruby do
    :plain
      client.entries('content_type' => 'restaurant', 'fields.Location[within]' => '1,2,3,4')


:markdown
  This will return entries where `fields.location` is within the rectangle with:

  - Bottom left corner: latitude 1, longitude 2
  - Top right corner: latitude 3, longitude 4

%h5 Search within bounding circle

:markdown
  Similar to the "near me" use case, this lets you search for locations that are
  within a specific circle on the map. This can be useful for finding related
  Entries that are in the vicinity of another Entry.

= language_specific 'javascript', 'http' do

  :markdown

        fields.location[within]=1,2,3&content_type=restaurant

= language_specific 'objc' do

  = language_block :objc do
    :plain
      [client fetchEntriesMatching:@{ @"fields.location[within]": @[ @1, @2, @3 ],
                                      @"content_type": @"restaurant" }
                           success:^(CDAResponse *response, CDAArray *array) {
                              NSLog(@"%@", array);
                           } failure:^(CDAResponse *response, NSError *error) {
                              NSLog(@"Error: %@", error);
                           }];

= language_specific 'swift' do

  = language_block :swift do
    :plain
      client.fetchEntriesMatching([ "fields.location[within]": [ 1, 2, 3 ],
                                    "content_type": "restaurant" ],
        success: { (response: CDAResponse!, array: CDAArray!) -> Void in
          println((array.items[0] as CDAEntry).fields.allKeys)
        },
        failure: { (response: CDAResponse!, error: NSError!) -> Void in
          println(error)
        })

= language_specific 'ruby' do
  = language_block :ruby do
    :plain
      client.entries('content_type' => 'restaurant', 'fields.Location[within]' => '1,2,3')


:markdown
  This will return Entries where `fields.location` is inside of the circle
  with latitude=1, longitude=2 and a radius of 3 kilometers.

= title_anchor 'h3', "search-order", "Order"

:markdown
  Order `items` by specifying the `order` search parameter.

  Let's get all Content Types ordered by their creation date:

= code_examples do
  = language_block :java do
    :plain
      client.entries().async().fetchAll(
          new HashMap<String, String>() {{
            put("order", "sys.createdAt");
          }},

          new CDACallback<CDAArray>() {
            @Override protected void onSuccess(CDAArray result) {
              // ...
            }
          });

  = language_block :javascript do
    :plain
      client.entries({
        order: 'sys.createdAt'
      }).then(log.ok, log.fail);

  = language_block :shell do
    = curl path: "/spaces/#{space}/entries?order=sys.createdAt"

  = api_console_trigger :action => 'entries', :params => {:ordering => ['order;order;sys.createdAt']}

  = language_block :objc do
    :plain
      [client fetchEntriesMatching:@{ @"order": @"sys.createdAt" }
                           success:^(CDAResponse *response, CDAArray *array) {
                               NSLog(@"%@", array);
                           } failure:^(CDAResponse *response, NSError *error) {
                               NSLog(@"%@", error);
                           }];
  = language_block :swift do
    :plain
      client.fetchEntriesMatching([ "order": "sys.createdAt" ],
        success: { (response: CDAResponse!, array: CDAArray!) -> Void in
          println((array.items[0] as CDAEntry).fields.allKeys)
        },
        failure: { (response: CDAResponse!, error: NSError!) -> Void in
          println(error)
        })
  = language_block :ruby do
    :plain
      client.entries('order' => 'sys.createdAt')

:markdown
  Reverse the sort-order by prefixing the field with a minus-sign.

  For example, order by time of last update starting with the newest Entries.

= code_examples do
  = language_block :java do
    :plain
      client.entries().async().fetchAll(
          new HashMap<String, String>() {{
            put("order", "-sys.updatedAt");
          }},

          new CDACallback<CDAArray>() {
            @Override protected void onSuccess(CDAArray result) {
              // ...
            }
          });

  = language_block :javascript do
    :plain
      client.entries({
        order: '-sys.updatedAt'
      }).then(log.ok, log.fail);

  = language_block :shell do
    = curl path: "/spaces/#{space}/entries?order=-sys.updatedAt"

  = api_console_trigger :action => 'entries', :params => {:ordering => ['order;order;-sys.createdAt']}

  = language_block :objc do
    :plain
      [client fetchEntriesMatching:@{ @"order": @"-sys.updatedAt" }
                           success:^(CDAResponse *response, CDAArray *array) {
                               NSLog(@"%@", array);
                           } failure:^(CDAResponse *response, NSError *error) {
                               NSLog(@"%@", error);
                           }];
  = language_block :swift do
    :plain
      client.fetchEntriesMatching([ "order": "-sys.updatedAt" ],
        success: { (response: CDAResponse!, array: CDAArray!) -> Void in
          println((array.items[0] as CDAEntry).fields.allKeys)
        },
        failure: { (response: CDAResponse!, error: NSError!) -> Void in
          println(error)
        })
  = language_block :ruby do
    :plain
      client.entries('order' => '-sys.createdAt')


:markdown
  Note that when ordering Entries by `fields` you must set the
  [`content_type` URI query parameter](#search-content-type)
  to the ID of the Content Type you want to filter by.

= title_anchor 'h3', "search-limit", "Limit & Skip"

:markdown
  Specify the maximum number of results as `limit` search parameter:

  Example: Limit to 3 Entries

= code_examples do
  = language_block :java do
    :plain
      client.entries().async().fetchAll(
          new HashMap<String, String>() {{
            put("limit", "3");
          }},

          new CDACallback<CDAArray>() {
            @Override protected void onSuccess(CDAArray result) {
              // ...
            }
          });

  = language_block :javascript do
    :plain
      client.entries({limit: 3}).then(log.ok, log.fail);

  = language_block :shell do
    = curl path: "/spaces/#{space}/entries?limit=3"

  = api_console_trigger :action => 'entries', :params => {:limiting => ['limit;limit;3']}

  = language_block :objc do
    :plain
      [client fetchEntriesMatching:@{ @"limit": @3 }
                           success:^(CDAResponse *response, CDAArray *array) {
                               NSLog(@"%@", array);
                           } failure:^(CDAResponse *response, NSError *error) {
                               NSLog(@"%@", error);
                           }];
  = language_block :swift do
    :plain
      client.fetchEntriesMatching([ "limit": 3 ],
        success: { (response: CDAResponse!, array: CDAArray!) -> Void in
          println((array.items[0] as CDAEntry).fields.allKeys)
        },
        failure: { (response: CDAResponse!, error: NSError!) -> Void in
          println(error)
        })
  = language_block :ruby do
    :plain
      client.entries('limit' =>'1')


:markdown
  Please note that the maximum number of entries returned by the API is 1000. Limits higher than 1000
  will be ignored.


:markdown
  Specify an offset as the `skip` search parameter:

  Example: Skip 3 Entries

= code_examples do
  = language_block :java do
    :plain
      client.entries().async().fetchAll(
          new HashMap<String, String>() {{
            put("skip", "3");
          }},

          new CDACallback<CDAArray>() {
            @Override protected void onSuccess(CDAArray result) {
              // ...
            }
          });

  = language_block :javascript do
    :plain
      client.entries({skip: 3}).then(log.ok, log.fail);

  = language_block :shell do
    = curl path: "/spaces/#{space}/entries?skip=3"

  = api_console_trigger :action => 'entries', :params => {:limiting => ['skip;skip;3']}

  = language_block :objc do
    :plain
      [client fetchEntriesMatching:@{ @"skip": @3 }
                           success:^(CDAResponse *response, CDAArray *array) {
                               NSLog(@"%@", array);
                           } failure:^(CDAResponse *response, NSError *error) {
                               NSLog(@"%@", error);
                           }];

  = language_block :swift do
    :plain
      client.fetchEntriesMatching([ "skip": 3 ],
        success: { (response: CDAResponse!, array: CDAArray!) -> Void in
          println((array.items[0] as CDAEntry).fields.allKeys)
        },
        failure: { (response: CDAResponse!, error: NSError!) -> Void in
          println(error)
        })

  = language_block :ruby do
    :plain
      client.entries('skip' =>'3')


:markdown
  By combining skip and limit you can achieve pagination:

  - Page 1: skip=0, limit=15
  - Page 2: skip=15, limit=15
  - Page 3: skip=30, limit=15
  - etc.

-# TODO: somewhere have a list of some more complicated example queries. many people don't want to read the details, they prefer to copy paste and tweak something

= title_anchor 'h3', "search-link", "Including linked Entries in search results"

:markdown
  [Links](#links) are a very powerful way to model relationships between
  pieces of content. Contentful's search is built to make linked data retrieval
  as simple as adding an additional URI query parameter to retrieve an entire
  web of related content that you can display in your application.

  Basically Resources can have Link fields which point to other Entries or
  Assets.

  When you have related content (e.g. Entries with links to other Entries)
  it's possible include both search results and related data in a single request.

  Simply tell the search to include the targets of links in the response:
  Set the `include` parameter to the number of levels you want to resolve.
  The maximum number of inclusion is 10.

  To illustrate this, note that the cat Content Type has a Link field that links
  to the cat's best friend.

  Let's serach for the `nyancat` Entry and include 1 level of linked Entries:

= code_examples do
  = language_block :java do
    :plain
      client.entries().async().fetchAll(
          new HashMap<String, String>() {{
            put("sys.id", "nyancat");
            put("include", "1");
          }},

          new CDACallback<CDAArray>() {
            @Override protected void onSuccess(CDAArray result) {
              // ...
            }
          });
  = language_block :javascript do
    :plain
      client.entries({
        'sys.id': 'nyancat',
        'include': 1
      }).then(log.ok, log.fail);
  = language_block :shell do
    = curl path: "/spaces/#{space}/entries?sys.id=nyancat&include=1"
  = language_block :objc do
    :plain
       [client fetchEntriesMatching:@{ @"sys.id": @"nyancat", @"include": @(1) }
                             success:^(CDAResponse *response, CDAArray *array) {
                                 NSLog(@"%@", array);
                             } failure:^(CDAResponse *response, NSError *error) {
                                 NSLog(@"%@", error);
                             }];
  = language_block :swift do
    :plain
      client.fetchEntriesMatching([ "sys.id": "nyancat", "include": 1 ],
        success: { (response: CDAResponse!, array: CDAArray!) -> Void in
          println((array.items[0] as CDAEntry).fields.allKeys)
        },
        failure: { (response: CDAResponse!, error: NSError!) -> Void in
          println(error)
        })
  = language_block :ruby do
    :plain
      client.entries('sys.id' => 'nyancat', include: 1)

:markdown
  The search result will include the requested Entry matching the query in
  `items` along with the linked Entries and Assets in `includes`.

  Link resolution works regardless of how many results are there in `items`.
  Some examples for this are:

  - Get a list of blog posts in `items` with related authors, categories and
    other meta data in `includes`.
  - Get a single restaurant in `items` along with its menu, menu items and
    photos (Assets) in `includes`.

= language_specific 'javascript', 'http' do

  :markdown
    Important note: If an item is already present in the response's `items`,
    __it will not be included in the include.Entry again!__

    The JS library resolves links automatically: If you query with `include` links
    will be replaced with references to the actual objects.

= language_specific 'java' do
  :markdown
    The Java SDK will resolve included links automatically.

= language_specific 'objc', 'swift' do

  :markdown
    The Objective-C SDK will resolve included links automatically. You can check if a Resource is only linked by querying the `fetched` property, which tells you if the actual content is available locally.

    Unfetched resources can be retrieved like this:

  = code_examples do
    = language_block :objc do
      :plain
        [currentResource resolveWithSuccess:^(CDAResponse *response, CDAResource *resource) {
            NSLog(@"resolved: %d", resource.fetched);
        } failure:^(CDAResponse *response, NSError *error) {
            NSLog(@"%@", error);
        }];
    = language_block :swift do
      :plain
        currentResource.resolveWithSuccess(
          { (response: CDAResponse!, resource : CDAResource!) -> Void in
            println("resolved: %d", resource.fetched)
          }, failure: { (response : CDAResponse!, error: NSError!) -> Void in
            println("Error: %@", error)
          })

= language_specific 'ruby' do
  :markdown
    The Ruby SDK will not resolve include links automatically. Linked resources can be fetched like this:

  = language_block :ruby do
    :plain
      happycat = client.entry('happycat')
      happycat.fields[:image]
      # => #<Contentful::Link: @sys={:type=>"Link", :linkType=>"Asset", :id=>"happycat"}>
      happycat.fields[:image].resolve # => #<Contentful::Asset: @fields={ ...
